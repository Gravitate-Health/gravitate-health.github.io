"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[211],{3756:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"tutorial-Preprocessor/Introduction","title":"Introduction","description":"This document provides essential guidance for developers creating Preprocessor services within the Federated Open-Source Platform and Services (FOSPS) environment, particularly focusing on the annotation process for Electronic Product Information (ePI).","source":"@site/docs/tutorial-Preprocessor/0 - Introduction.md","sourceDirName":"tutorial-Preprocessor","slug":"/tutorial-Preprocessor/Introduction","permalink":"/docs/tutorial-Preprocessor/Introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/gravitate-health/gravitate-health.github.io/tree/main/docs/tutorial-Preprocessor/0 - Introduction.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Tutorial - Preprocessor","permalink":"/docs/category/tutorial---preprocessor"},"next":{"title":"Develop a Basic Preprocessor","permalink":"/docs/tutorial-Preprocessor/Develop a Basic Preprocessor"}}');var s=n(4848),o=n(8453);const r={sidebar_position:1},a="Introduction",c={},l=[{value:"What Are Preprocessors?",id:"what-are-preprocessors",level:2},{value:"Role in ePI Annotation",id:"role-in-epi-annotation",level:2},{value:"Role in the Focusing Mechanism",id:"role-in-the-focusing-mechanism",level:2},{value:"Understanding the use of standard terminologies (e.g., SNOMED-CT, ICPC-2) for annotation",id:"understanding-the-use-of-standard-terminologies-eg-snomed-ct-icpc-2-for-annotation",level:2},{value:"Use of the HtmlElementLink Extension",id:"use-of-the-htmlelementlink-extension",level:3},{value:"Preprocessor Execution",id:"preprocessor-execution",level:2},{value:"Technical Requirements for Preprocessor HTML Modification",id:"technical-requirements-for-preprocessor-html-modification",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,s.jsx)(t.p,{children:"This document provides essential guidance for developers creating Preprocessor services within the Federated Open-Source Platform and Services (FOSPS) environment, particularly focusing on the annotation process for Electronic Product Information (ePI)."}),"\n",(0,s.jsx)(t.h2,{id:"what-are-preprocessors",children:"What Are Preprocessors?"}),"\n",(0,s.jsx)(t.p,{children:"A preprocessor is a software service that annotates an ePI for further processing. Preprocessors are designed to be pluggable components that integrate seamlessly into the platform's focusing workflow. They operate dynamically and can be configured as modules that the Focusing Manager automatically identifies and invokes when an ePI requires preprocessing."}),"\n",(0,s.jsx)(t.h2,{id:"role-in-epi-annotation",children:"Role in ePI Annotation"}),"\n",(0,s.jsx)(t.p,{children:"Preprocessors are tasked with performing semantic annotation on ePI content. This crucial process involves reading the ePI and automatically annotating parts of the narrative text. Specifically, preprocessors identify text sections containing information about any topic and semantically link them to clinical terminologies.\nThe goal of semantic annotation is to transform the unstructured narrative text of the ePI into a structured representation, making the information easier to analyze, search, and understand for subsequent processes. These annotations typically consist of codes from standard terminologies, such as SNOMED-CT or ICPC-2."}),"\n",(0,s.jsx)(t.h2,{id:"role-in-the-focusing-mechanism",children:"Role in the Focusing Mechanism"}),"\n",(0,s.jsx)(t.p,{children:"Preprocessing is the first step in the multi-stage focusing process. The focusing mechanism itself is defined as adapting information to the context of the end user for effective and optimal understanding of the information.\nThe output of the preprocessing stage is the preprocessed ePI, or p(ePI). The p(ePI) retains the original text content of the raw ePI but is enriched with metadata embedded within the text, matching text sections to for example clinical terminologies. This annotated ePI is then ready to be consumed by the Lenses, which contain the logic for personalization based on user context (like their IPS or prefrecences).\nPreprocessors must be built with the understanding that they may be stacked, i.e., executed sequentially, with other preprocessors to generate a complete annotation of the ePI. The Focusing Manager coordinates this orchestration."}),"\n",(0,s.jsx)(t.h2,{id:"understanding-the-use-of-standard-terminologies-eg-snomed-ct-icpc-2-for-annotation",children:"Understanding the use of standard terminologies (e.g., SNOMED-CT, ICPC-2) for annotation"}),"\n",(0,s.jsx)(t.p,{children:"Semantic annotation within the FOSPS relies on the principle of linking sections of the ePI narrative text to standard medical vocabularies, such as SNOMED-CT (Systematized Nomenclature of Medicine Clinical Terms) and ICPC-2 (International Classification of Primary Care version 2). The usage of these standard terminologies is essential to standardize clinical and medical nomenclature and definitions across the platform."}),"\n",(0,s.jsx)(t.h3,{id:"use-of-the-htmlelementlink-extension",children:"Use of the HtmlElementLink Extension"}),"\n",(0,s.jsxs)(t.p,{children:["The mechanism used to link these standard terminology concepts (codes) to specific parts of the ePI narrative text relies on the ",(0,s.jsx)(t.a,{href:"https://build.fhir.org/ig/hl7-eu/gravitate-health/StructureDefinition-HtmlElementLink.html",children:"HtmlElementLink FHIR extension"}),".\nThe HtmlElementLink extension is complex and is utilized for adding information\u2014which may be pictograms, images, video, or other flexible types of data\u2014to ePIs in the FHIR format. It is typically applied to the Composition resource within the ePI Bundle.\nThis extension contains sub-extensions to define the linkage:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["extension",":concept"]}),": This mandatory component specifies the data to be used, which is generally a reference to a resource, a CodeableConcept (such as a SNOMED-CT or ICPC-2 code), a URL, or a string. This is the standard terminology code representing the clinical concept being annotated."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["extension",":elementClass"]}),": This component, required for linking, specifies the location in the HTML to which the concept applies. This value is a string intended to be used as an HTML class attribute."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"By declaring the concept (code) and linking it to a specific elementClass using the HtmlElementLink extension, preprocessors enable the narrative text (which is contained within HTML) to feature class attributes that reference these defined concepts."}),"\n",(0,s.jsx)(t.h2,{id:"preprocessor-execution",children:"Preprocessor Execution"}),"\n",(0,s.jsxs)(t.p,{children:["A Preprocessor is implemented as a containerized service module that is pluggable into FOSPS. This service must expose an endpoint (typically ",(0,s.jsx)(t.code,{children:"/preprocess"}),") that receives the entire ePI resource in its body and responds with the preprocessed version, having performed the semantic annotation. The preprocessed response should maintain the original FHIR format of the input ePI, ensuring that no changes are made to the underlying data structure. This simple service is specified in ",(0,s.jsx)(t.a,{href:"https://raw.githubusercontent.com/Gravitate-Health/preprocessing-service-example/refs/heads/main/openapi.yaml",children:"OpenAPI"})," for developer convenience."]}),"\n",(0,s.jsx)(t.p,{children:"Preprocessors must be implemented as separate services, allowing them to be easily developed, tested, and maintained independently of the rest of the system. This modularity enables a wide range of preprocessing techniques to be integrated into FOSPS, making it possible to handle various use cases and requirements in different languages using different frameworks."}),"\n",(0,s.jsxs)(t.p,{children:["To enable the focusing manager component to locate and orchestrate preprocessors, each preprocessor service should be launched with a specific tag: ",(0,s.jsx)(t.code,{children:"eu.gravitate-health.fosps.preprocessing=True"}),". This allows the focusing manager to identify available preprocessors and direct incoming ePI resources through the relevant preprocessing pipeline. The focusing manager will then forward the preprocessed output to the next stage of processing."]}),"\n",(0,s.jsx)(t.p,{children:"By following this design pattern, developers can easily create and integrate new preprocessing algorithms into FOSPS, enhancing its capabilities and flexibility in handling diverse healthcare data formats and use cases."}),"\n",(0,s.jsx)(t.h2,{id:"technical-requirements-for-preprocessor-html-modification",children:"Technical Requirements for Preprocessor HTML Modification"}),"\n",(0,s.jsx)(t.p,{children:"When generating annotations, preprocessors must adhere to strict constraints regarding HTML modifications to ensure regulatory compliance and proper functioning within the Focusing Mechanism:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Modification Limits (",(0,s.jsx)(t.strong,{children:"No Content Editing"}),"): The content of the ePI is highly regulated and must be preserved exactly as approved. Preprocessors must not remove any content or change the narrative content of the original ePI. Edits are strictly limited to technical modifications of the HTML structure:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Adding HTML class attributes."}),"\n",(0,s.jsx)(t.li,{children:"Adding new HTML tags for the purpose of supplementary information or delineation."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["Adding Classes to Existing Tags: Preprocessors should utilize HTML markup language to target text portions. Annotations are commonly applied by adding classes to existing HTML tags, such as header tags (",(0,s.jsx)(t.code,{children:"<H1>"}),") or list items (",(0,s.jsx)(t.code,{children:"<UL>"}),", ",(0,s.jsx)(t.code,{children:"<IL>"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["Generating Invisible Tags: To mark arbitrary text segments for annotation without affecting the display style, preprocessors may use non-style-changing tags. The preferred tag for selecting arbitrary text is the ",(0,s.jsx)(t.code,{children:"<span>"})," tag."]}),"\n",(0,s.jsxs)(t.li,{children:["Stacking Awareness: Since preprocessors can be stacked, i.e. a preprocessor's input may be the output of one or more previous preprocessors, and viceversa; Developers should implement logic that checks for existing attributes and handles their concatenation to maintain a clean and effective structure. Some considerations include:","\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Duplicate prevention: avoid adding duplicates like extension",":concept",", or extension",":elementClass"," with the same values"]}),"\n",(0,s.jsx)(t.li,{children:"Avoiding HTML Nesting (Handling Existing Attributes): Developers must be aware that when applying annotations, they should avoid creating redundant or complex HTML structures. If a target HTML element already has a class attribute (potentially added by a preceding preprocessor), the new class attribute referencing the terminology concept should be added to the existing class attributes, rather than wrapping the element in a new, nested tag."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);